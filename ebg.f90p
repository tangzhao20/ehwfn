! find the band gap weighted by each exciton states
! Eg^S=sum_cvk((A_cvk^S)^2*(Eck-Evk+q))

program ehbandgap
  use typedefs
  use nrtype
  implicit none
  integer :: ns, nv, nc, nk, nmat, ie, imat, ik, ic, iv, is, ik1, ik2
  integer :: tmp_n
#ifdef CPLX
  complex(dpc), allocatable :: Aread(:) ! nmat
#else
  real(dp), allocatable :: Aread(:)! nmat
#endif
!  real(dp), allocatable :: Avcke(:,:,:,:) ! nv, nc, nk, j%ne
  real(dp), allocatable :: energy(:) ,Egap(:), Eb(:), Asum(:)! j%ne
  real(dp), allocatable :: Ec(:,:) ! nc, nk
  real(dp), allocatable :: Ev(:,:) ! nv, nk
  real(dp), allocatable :: kk(:,:)
  real(dp) :: tmp_kk(3), kshift(3), Avcke
  type(joblist) :: jobs
  integer :: ierr
  character(len=80) :: filename
  character(len=80) :: something
  character(len=11) :: cdate
  character(len=14) :: ctime

  open(unit=881,file="out.dat",status="replace")
  call date_time(cdate, ctime)
  write(881,'(a,a11,1x,a14)') " Start Time: ", cdate, ctime


  call readin(jobs)

  write(881,*)
  write(881,*) "reading file eigenvectors headers"
  open(unit=10,file="eigenvectors",form='unformatted',status='old')


  read(10) ns
  read(10) nv
  read(10) nc
  read(10) nk
  nmat=ns*nv*nc*nk

  write(881,'(a,i0)') " ns = ", ns
  write(881,'(a,i0)') " nv = ", nv
  write(881,'(a,i0)') " nc = ", nc
  write(881,'(a,i0)') " nk = ", nk
  write(881,'(a,i0)') " nmat = ", nmat

  allocate(kk(3,nk))
  read(10) kk(:,:) ! kpoints

  write(881,*)
  write(881,*) "reading file eqp.dat for Eck"
  open(unit=13,file="eqp.dat",form="formatted",status="old")
  allocate(Ec(nc,nk))
  do ik = 1, nk
    read(13,*)tmp_kk(:), tmp_n
    if (Sum(Dabs(kk(:,ik)-tmp_kk))>1.d-6) then
      Call die("k points of eigenvectors and eqp.dat doesn`t match")
    endif
    if (nc>tmp_n) then
      Call die("more conduction bands in eigenvectors than eqp.dat")
    endif
    do ic = 1, nc
      read(13,*) something, something, something, Ec(ic,ik)
    enddo ! ic
    do ic = nc+1, tmp_n, 1
      read(13,*) ! padding to tmpnc
    enddo ! ic
  enddo ! ik
  close(13)

  
  write(881,*)
  write(881,*) "reading file eqp_q.dat for Evk"
  open(unit=14,file="eqp_q.dat",form="formatted",status="old")
  allocate(Ev(nv,nk))
  do ik = 1, nk
    read(14,*)tmp_kk(:), tmp_n
    if (ik==1) then
      ik2=1
      kshift=tmp_kk-kk(:,1)
      write(881,'(a,3f9.5)') " kshift = ", kshift
    else ! ik/=1
      ik2=0
      do ik1=2, nk
        if (Sum(Dabs(kk(:,ik1)+kshift-tmp_kk))<1.d-6) then
          ik2=ik1
          exit
        endif
      enddo
      if (ik2==0) then
        Call die("k points of eigenvectors and eqp_q.dat doesn`t match")
      endif
    endif ! ik==1
    if (nv>tmp_n) then
      Call die("more valence bands in eigenvectors than eqp_q.dat")
    endif
    do iv = nv+1, tmp_n, 1
      read(14,*) ! padding to tmp_n
    enddo ! iv
    do iv = nv, 1, -1
      read(14,*) something, something, something, Ev(iv,ik2)
    enddo ! iv
  enddo ! ik
  close(14)

  if (jobs%lwkpoints) then
    write(881,"(a)") " klist: "
  endif
  do ik = 1, nk
    if (jobs%lwkpoints) then
      write(881,'(i6,3(f10.6))')ik,kk(:,ik)
    elseif (jobs%lwbands) then
      write(881,'(i6)')ik
    endif
    if (jobs%lwbands) then
      write(881,*) "   Ev:"
      do iv = nv, 1, -1
        write(881,'(f18.9)')Ev(iv,ik)
      enddo
      write(881,*) "   Ec:"
      do ic = 1, nc
        write(881,'(f18.9)')Ec(ic,ik)
      enddo
    endif
  enddo



  write(881,*)
  write(881,*) "reading file eigenvectors"

  allocate(Aread(nmat))
!  allocate(Avcke(nv,nc,nk,jobs%ne))
  allocate(energy(jobs%ne))
  allocate(Asum(jobs%ne))
  allocate(Egap(jobs%ne))
  allocate(Eb(jobs%ne))
  Asum=0.d0
#ifdef CPLX
  Egap=(0.d0,0.d0)
!  Avcke=(0.d0,0.d0)
#else
!  Avcke=0.d0
  Egap=0.d0
#endif

  do ie = 1, jobs%ne
    read(10) energy(ie)
    read(10) Aread(:)
    imat = 0
    do ik = 1, nk
      do ic = 1, nc
        do iv = 1, nv
          do is = 1, ns
            imat=ik-1
            imat=imat*nc+ic-1
            imat=imat*nv+iv-1
            imat=imat*ns+is ! -1+1
#ifdef CPLX
            Avcke = Aread(imat) * conjg(Aread(imat))
#else
            Avcke = Aread(imat) **2
#endif
            Egap(ie)=Egap(ie)+Avcke*(Ec(ic,ik)-Ev(iv,ik))
            Asum(ie)=Asum(ie)+Avcke
          enddo ! is
        enddo ! iv
      enddo ! ic
    enddo ! ik

  enddo ! ie
  close(10)
  deallocate(Aread)

  if (maxval(Asum)<1.d0+1.d-6 .and. minval(Asum)>1.d0-1.d-6) then
    write(881,*)"AvckS normalization checked, sum_vck(|AvckS|^2)=1"
  else
    write(881,*)"AvckS is not normalized, sum_vck(|AvckS|^2) /= 1"
    do ie = 1, jobs%ne
      write(881,"(i6,f9.5)") ie,Asum(ie)
    enddo ! ie
    call die("AvckS is not normalized")
  endif
  deallocate(Asum)


  Eb=Egap-energy
  open(unit=15,file="energy.dat",status="replace")
  write(15,*) "exciton Eexciton(eV) Egap(eV) Ebinding(eV)"
  do ie = 1, jobs%ne
    write(15,"(i5, 3f9.5)") ie, energy(ie), Egap(ie), Eb(ie)
  enddo
  close(15)

  deallocate(Eb)
  deallocate(Egap)
  deallocate(Ev)
  deallocate(Ec)
  deallocate(kk)
!  deallocate(Avcke)
  deallocate(energy)
  write(881,*) 
  call date_time(cdate, ctime)
  write(881,'(a,a11,1x,a14)') " End Time: ", cdate, ctime
endprogram ehbandgap

subroutine date_time(bdate,btime)
  ! returns:
  ! - bdate: string with date
  ! - btime: string with time
  character(len=11), intent(out) :: bdate
  character(len=14), intent(out) :: btime
  !
  integer :: lmonth
  integer :: idate(8)
  character(len=10) :: atime
  character(len=8) :: adate
  character(len=5) :: azone
  character(len=4) :: year
  character(len=3) :: month(12)
  character(len=2) :: hour, min, sec, day
  !
  DATA month/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep', &
       'Oct','Nov','Dec'/
  !

  call date_and_time(adate,atime,azone,idate)
  read(adate,"(a4,i2,a2)") year, lmonth, day
  write(bdate,"(a2,a1,a3,a1,a4)") day, '-', month(lmonth), '-', year
  read(atime,'(a2,a2,a2,a4)') hour, min, sec
  write(btime,"(a2,a1,a2,a1,a2,1x,a5)") hour, ':', min, ':', sec, azone
  !
  return
end subroutine date_time


subroutine die(str)!,id_cpu)
!  use mpi
  implicit none
  character (len=*) :: str
  integer :: ierr
!  integer, intent(In), optional :: id_cpu

  write(*,*)
  write(*,*) "Stop! ERROR in: ", Trim(str)
!  if (present(id_cpu)) write(*,*) "At cpu",id_cpu
  write(*,*)
  stop
!  call MPI_Abort(MPI_COMM_WORLD, 0, ierr)

endsubroutine die



